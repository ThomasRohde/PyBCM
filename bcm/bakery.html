<!DOCTYPE html>
<html>
<head>
    <style>
        .card {
            background: white;
            border-radius: 0.5rem;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1);
            margin: 1rem;
            max-width: 100%;
        }

        .card-header {
            padding: 1.5rem;
            border-bottom: 1px solid #e2e8f0;
        }

        .card-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: #1a202c;
        }

        .card-content {
            padding: 1.5rem;
            overflow: auto;
        }

        svg text {
            font-family: system-ui, -apple-system, sans-serif;
            font-size: 0.875rem;
            font-weight: 500;
        }

        .bg-white {
            background: white;
        }

        /* Add styles for SVG tooltips */
        .capability-tooltip {
            font-family: system-ui, -apple-system, sans-serif;
            font-size: 0.75rem;
            pointer-events: none;
        }

        /* Update tooltip styles */
        title {
            font-family: system-ui, -apple-system, sans-serif;
            font-size: 14px;
        }

        /* Tooltip styles */
        svg {
            pointer-events: none; /* Ensure tooltips work on child elements */
        }
        
        g, rect {
            pointer-events: all;
        }

        g:hover, rect:hover {
            /* Reduce delay before tooltip appears */
            transition-delay: 0s;
            transition-duration: 0s;
        }
    </style>
</head>
<body>
    <div class="card">
        <div class="card-content">
            <div id="svg-container"></div>
        </div>
    </div>

    <script>
        // Constants
        const BOX_MIN_WIDTH = 120;
        const BOX_MIN_HEIGHT = 60;
        const HORIZONTAL_GAP = 20;
        const VERTICAL_GAP = 20;
        const PADDING = 30;
        const DEFAULT_TARGET_ASPECT_RATIO = 1.0;
        const LINE_HEIGHT = 16; // Height of each text line
        const PADDING_TOP = 10; // Padding from top of box to text

        // Sample data with descriptions
        const capabilityModel = {"name": "Bakery", "description": "A small mom and pop bakery", "children": [{"name": "Product Development", "description": "Design and innovate new bakery products including recipes, flavors, and seasonal offerings.", "children": [{"name": "Market Research and Analysis", "description": "Conduct research to identify customer preferences, industry trends, and competitive offerings to inform new product development initiatives.", "children": null, "x": 0, "y": 0, "width": 120, "height": 60}, {"name": "Recipe Development and Innovation", "description": "Create and test new recipes for bakery products, including ingredients, methods, and presentation to deliver unique and appealing offerings.", "children": null, "x": 0, "y": 0, "width": 120, "height": 60}, {"name": "Product Testing and Feedback", "description": "Gather and analyze customer feedback on new products through trials and surveys to refine offerings before full-scale launch.", "children": null, "x": 0, "y": 0, "width": 120, "height": 60}, {"name": "Seasonal Product Planning", "description": "Design and develop bakery products tailored for seasonal events and holidays to enhance customer engagement and sales opportunities.", "children": null, "x": 0, "y": 0, "width": 120, "height": 60}, {"name": "Nutritional Analysis and Compliance", "description": "Evaluate and document the nutritional content of new products to meet regulatory standards and support customer health choices.", "children": null, "x": 0, "y": 0, "width": 120, "height": 60}, {"name": "Brand and Packaging Development", "description": "Create branding strategies and packaging designs that enhance product appeal and communicate quality and uniqueness to customers.", "children": null, "x": 0, "y": 0, "width": 120, "height": 60}, {"name": "Costing and Pricing Strategy", "description": "Determine the production costs of new products and develop pricing strategies that balance profitability with customer value.", "children": null, "x": 0, "y": 0, "width": 120, "height": 60}, {"name": "Product Launch Planning", "description": "Plan and execute the introduction of new products to the market, coordinating marketing efforts, promotions, and distribution strategies.", "children": null, "x": 0, "y": 0, "width": 120, "height": 60}, {"name": "Ongoing Product Improvement", "description": "Continuously monitor product performance and customer feedback to implement improvements that enhance quality and sales.", "children": null, "x": 0, "y": 0, "width": 120, "height": 60}, {"name": "Sustainability Integration in Product Development", "description": "Incorporate sustainable practices in product development, evaluating sourcing and production methods to align with environmental goals.", "children": null, "x": 0, "y": 0, "width": 120, "height": 60}], "x": 0, "y": 0, "width": 120, "height": 60}, {"name": "Ingredient Sourcing", "description": "Identify, negotiate, and procure high-quality ingredients from suppliers to ensure product excellence.", "children": null, "x": 0, "y": 0, "width": 120, "height": 60}, {"name": "Production Management", "description": "Oversee the baking process, manage production schedules, and ensure efficient use of resources.", "children": [{"name": "Production Scheduling", "description": "Manage and optimize baking schedules to ensure efficient use of time and resources, align with order demands, and minimize downtime.", "children": null, "x": 0, "y": 0, "width": 120, "height": 60}, {"name": "Resource Allocation", "description": "Oversee the allocation and utilization of ingredients, equipment, and personnel during production to enhance operational efficiency and reduce waste.", "children": null, "x": 0, "y": 0, "width": 120, "height": 60}, {"name": "Process Optimization", "description": "Analyze and refine baking processes to increase efficiency, reduce costs, and improve quality, ensuring that production methods are continuously improved.", "children": null, "x": 0, "y": 0, "width": 120, "height": 60}, {"name": "Production Capacity Management", "description": "Evaluate and manage the production capacity to ensure that the bakery can meet current and future demand without compromising quality.", "children": null, "x": 0, "y": 0, "width": 120, "height": 60}, {"name": "Production Monitoring and Reporting", "description": "Implement tracking systems to monitor production performance and resource usage, generating reports that inform decision-making and identify areas for improvement.", "children": null, "x": 0, "y": 0, "width": 120, "height": 60}, {"name": "Batch Production Management", "description": "Coordinate and control the production of batches of baked goods, ensuring consistency in quality and adherence to recipes.", "children": null, "x": 0, "y": 0, "width": 120, "height": 60}, {"name": "Staff Coordination and Management", "description": "Manage and schedule staff involved in production, ensuring that training and competencies align with production requirements.", "children": null, "x": 0, "y": 0, "width": 120, "height": 60}, {"name": "Production Compliance Management", "description": "Ensure all production processes adhere to health and safety regulations, quality standards, and company policies, mitigating risks associated with non-compliance.", "children": null, "x": 0, "y": 0, "width": 120, "height": 60}, {"name": "Inventory Control for Production", "description": "Monitor and manage inventory levels of ingredients and raw materials to ensure continuous production without interruptions or overstocking.", "children": null, "x": 0, "y": 0, "width": 120, "height": 60}, {"name": "Sustainability Practices in Production", "description": "Incorporate sustainable practices into the production process, focusing on waste reduction, energy efficiency, and eco-friendly sourcing.", "children": null, "x": 0, "y": 0, "width": 120, "height": 60}], "x": 0, "y": 0, "width": 120, "height": 60}, {"name": "Quality Control", "description": "Implement quality assurance processes to maintain product standards and ensure customer satisfaction.", "children": null, "x": 0, "y": 0, "width": 120, "height": 60}, {"name": "Customer Service", "description": "Engage with customers, provide assistance, and resolve inquiries to foster a positive experience.", "children": null, "x": 0, "y": 0, "width": 120, "height": 60}, {"name": "Sales and Marketing", "description": "Promote products through various channels, manage sales strategies, and build customer relationships.", "children": null, "x": 0, "y": 0, "width": 120, "height": 60}, {"name": "Order Fulfillment", "description": "Manage the processing and delivery of customer orders, ensuring timely and accurate service.", "children": null, "x": 0, "y": 0, "width": 120, "height": 60}, {"name": "Financial Management", "description": "Monitor and manage the bakery\u2019s finances, including budgeting, accounting, and cost control.", "children": null, "x": 0, "y": 0, "width": 120, "height": 60}, {"name": "Inventory Management", "description": "Track inventory levels of ingredients and products to optimize stock and reduce waste.", "children": null, "x": 0, "y": 0, "width": 120, "height": 60}, {"name": "Safety and Compliance", "description": "Ensure adherence to food safety regulations and health standards for a safe baking environment.", "children": null, "x": 0, "y": 0, "width": 120, "height": 60}, {"name": "Training and Development", "description": "Provide training for staff in baking techniques, customer service, and operational procedures.", "children": null, "x": 0, "y": 0, "width": 120, "height": 60}, {"name": "Facility Management", "description": "Maintain a clean, functional, and welcoming baking environment for staff and customers.", "children": null, "x": 0, "y": 0, "width": 120, "height": 60}, {"name": "Community Engagement", "description": "Foster relationships with local community organizations and participate in community events.", "children": null, "x": 0, "y": 0, "width": 120, "height": 60}, {"name": "Supplier Relationship Management", "description": "Develop and maintain strong partnerships with suppliers for consistent sourcing and quality.", "children": null, "x": 0, "y": 0, "width": 120, "height": 60}, {"name": "Marketing Analytics", "description": "Analyze market trends and customer feedback to inform marketing strategies and product offerings.", "children": null, "x": 0, "y": 0, "width": 120, "height": 60}, {"name": "Sustainability Practices", "description": "Implement practices for sustainable sourcing, production, and waste management.", "children": null, "x": 0, "y": 0, "width": 120, "height": 60}, {"name": "Digital Transformation", "description": "Leverage technology for online sales, marketing, and operational efficiency.", "children": null, "x": 0, "y": 0, "width": 120, "height": 60}], "x": 0, "y": 0, "width": 120, "height": 60};

        function calculateNodeSize(node) {
            if (!node.children || node.children.length === 0) {
                return {
                    width: BOX_MIN_WIDTH,
                    height: BOX_MIN_HEIGHT
                };
            }

            const childSizes = node.children.map(calculateNodeSize);

            let bestLayout = {
                rows: 1,
                cols: node.children.length,
                width: 0,
                height: 0,
                deviation: Infinity,
                positions: []
            };

            for (let rows = 1; rows <= node.children.length; rows++) {
                const cols = Math.ceil(node.children.length / rows);
                
                let rowHeights = new Array(rows).fill(0);
                let colWidths = new Array(cols).fill(0);
                
                for (let i = 0; i < node.children.length; i++) {
                    const row = Math.floor(i / cols);
                    const col = i % cols;
                    const size = childSizes[i];
                    
                    rowHeights[row] = Math.max(rowHeights[row], size.height);
                    colWidths[col] = Math.max(colWidths[col], size.width);
                }
                
                const gridWidth = colWidths.reduce((a, b) => a + b, 0) + (cols - 1) * HORIZONTAL_GAP;
                const gridHeight = rowHeights.reduce((a, b) => a + b, 0) + (rows - 1) * VERTICAL_GAP;
                
                const totalWidth = gridWidth + 2 * PADDING;
                const totalHeight = gridHeight + 2 * PADDING;
                const aspectRatio = totalWidth / totalHeight;
                const deviation = Math.abs(aspectRatio - DEFAULT_TARGET_ASPECT_RATIO);

                const positions = [];
                let yOffset = PADDING;
                
                for (let row = 0; row < rows; row++) {
                    let xOffset = PADDING;
                    for (let col = 0; col < cols; col++) {
                        const index = row * cols + col;
                        if (index < node.children.length) {
                            positions[index] = {
                                x: xOffset,
                                y: yOffset,
                                width: colWidths[col],
                                height: rowHeights[row]
                            };
                        }
                        xOffset += colWidths[col] + HORIZONTAL_GAP;
                    }
                    yOffset += rowHeights[row] + VERTICAL_GAP;
                }

                if (deviation < bestLayout.deviation) {
                    bestLayout = {
                        rows,
                        cols,
                        width: totalWidth,
                        height: totalHeight,
                        deviation,
                        positions
                    };
                }
            }

            return bestLayout;
        }

        function layoutTree(node, x = 0, y = 0) {
            const layout = calculateNodeSize(node);
            node.x = x;
            node.y = y;
            node.width = layout.width;
            node.height = layout.height;

            if (node.children && node.children.length > 0) {
                node.children.forEach((child, i) => {
                    const pos = layout.positions[i];
                    layoutTree(
                        child,
                        x + pos.x,
                        y + pos.y
                    );
                    child.width = pos.width;
                    child.height = pos.height;
                });
            }

            return node;
        }

        function createSVGElement(tagName, attributes = {}) {
            const element = document.createElementNS("http://www.w3.org/2000/svg", tagName);
            Object.entries(attributes).forEach(([key, value]) => {
                element.setAttribute(key, value);
            });
            return element;
        }

        function wrapText(text, width) {
            const words = text.split(' ');
            const lines = [];
            let currentLine = words[0];

            // Create temporary SVG to measure text
            const svg = createSVGElement('svg');
            const tempText = createSVGElement('text', {
                'font-size': '0.875rem',
                'font-family': 'system-ui, -apple-system, sans-serif'
            });
            svg.appendChild(tempText);
            document.body.appendChild(svg);

            for (let i = 1; i < words.length; i++) {
                tempText.textContent = currentLine + ' ' + words[i];
                const textWidth = tempText.getComputedTextLength();

                if (textWidth < width - 20) {  // 20px padding
                    currentLine += ' ' + words[i];
                } else {
                    lines.push(currentLine);
                    currentLine = words[i];
                }
            }
            lines.push(currentLine);

            document.body.removeChild(svg);
            return lines;
        }

        function renderNode(node) {
            const group = createSVGElement("g");

            // Add tooltip to group
            if (node.description) {
                const groupTitle = createSVGElement("title");
                groupTitle.textContent = `${node.name}\n${node.description}`;
                group.appendChild(groupTitle);
            }

            const rect = createSVGElement("rect", {
                x: node.x,
                y: node.y,
                width: node.width,
                height: node.height,
                fill: node.children?.length ? "#f8fafc" : "#fff",
                stroke: "#475569",
                "stroke-width": "1",
                rx: "4"
            });
            
            // Add same tooltip to rectangle
            if (node.description) {
                const rectTitle = createSVGElement("title");
                rectTitle.textContent = `${node.name}\n${node.description}`;
                rect.appendChild(rectTitle);
            }
            
            group.appendChild(rect);

            // Wrap text and create multiple text lines
            const lines = wrapText(node.name, node.width);
            const totalTextHeight = lines.length * LINE_HEIGHT;
            const startY = node.children?.length ? 
                node.y + PADDING_TOP : 
                node.y + (node.height - totalTextHeight) / 2;

            lines.forEach((line, index) => {
                const text = createSVGElement("text", {
                    x: node.x + node.width / 2,
                    y: startY + (index * LINE_HEIGHT),
                    "text-anchor": "middle",
                    "dominant-baseline": "hanging"
                });
                text.textContent = line;
                group.appendChild(text);
            });

            if (node.children) {
                node.children.forEach(child => {
                    group.appendChild(renderNode(child));
                });
            }

            return group;
        }

        function init() {
            const layoutedTree = layoutTree(JSON.parse(JSON.stringify(capabilityModel)));
            
            const svg = createSVGElement("svg", {
                width: layoutedTree.width + 40,
                height: layoutedTree.height + 40,
                viewBox: `0 0 ${layoutedTree.width + 40} ${layoutedTree.height + 40}`,
                class: "bg-white"
            });

            svg.appendChild(renderNode(layoutedTree));
            document.getElementById("svg-container").appendChild(svg);
        }

        // Initialize when the page loads
        document.addEventListener("DOMContentLoaded", init);
    </script>
</body>
</html>