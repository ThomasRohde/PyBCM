<!DOCTYPE html>
<html>
<head>
    <style>
        .card {
            background: white;
            border-radius: 0.5rem;
            box-shadow: 0 1px 3px 0 rgba(0, 0, 0, 0.1);
            margin: 1rem;
            max-width: 100%;
        }

        .card-header {
            padding: 1.5rem;
            border-bottom: 1px solid #e2e8f0;
        }

        .card-title {
            font-size: 1.25rem;
            font-weight: 600;
            color: #1a202c;
        }

        .card-content {
            padding: 1.5rem;
            overflow: auto;
        }

        svg text {
            font-family: system-ui, -apple-system, sans-serif;
            font-size: 0.875rem;
            font-weight: 500;
        }

        .bg-white {
            background: white;
        }
    </style>
</head>
<body>
    <div class="card">
        <div class="card-content">
            <div id="svg-container"></div>
        </div>
    </div>

    <script>
        // Constants
        const BOX_MIN_WIDTH = 120;
        const BOX_MIN_HEIGHT = 60;
        const HORIZONTAL_GAP = 20;
        const VERTICAL_GAP = 20;
        const PADDING = 30;
        const DEFAULT_TARGET_ASPECT_RATIO = 1.0;
        const LINE_HEIGHT = 16; // Height of each text line
        const PADDING_TOP = 10; // Padding from top of box to text

        // Sample data
        const capabilityModel = {"id": "root", "name": "Capability Model", "children": [{"id": "1", "name": "Danske Bank", "children": [{"id": "2", "name": "Customer Relationship Management", "children": [{"id": "22", "name": "Customer Acquisition Management", "children": []}, {"id": "23", "name": "Customer Engagement Management", "children": []}, {"id": "24", "name": "Customer Service Optimization", "children": []}, {"id": "25", "name": "Customer Retention Strategies", "children": []}, {"id": "26", "name": "Customer Insights and Analytics", "children": []}, {"id": "27", "name": "Brand Relationship Management", "children": []}, {"id": "28", "name": "Multi-Channel Communication Management", "children": []}, {"id": "29", "name": "Customer Feedback and Improvement Programs", "children": []}, {"id": "30", "name": "Onboarding Experience Management", "children": []}, {"id": "31", "name": "Sales Enablement and Support", "children": []}]}, {"id": "3", "name": "Product Development", "children": [{"id": "32", "name": "Market Research Management", "children": []}, {"id": "33", "name": "Product Design and Prototyping", "children": []}, {"id": "34", "name": "Regulatory Compliance Integration", "children": []}, {"id": "35", "name": "Product Testing and Validation", "children": []}, {"id": "36", "name": "Product Launch Management", "children": []}, {"id": "37", "name": "Post-Launch Evaluation", "children": []}, {"id": "38", "name": "Portfolio Management", "children": []}, {"id": "39", "name": "Customer Feedback Integration", "children": []}, {"id": "40", "name": "Agile Development Practices", "children": []}, {"id": "41", "name": "Innovation Management", "children": []}]}, {"id": "4", "name": "Risk Management", "children": [{"id": "42", "name": "Credit Risk Assessment", "children": []}, {"id": "43", "name": "Market Risk Management", "children": []}, {"id": "44", "name": "Operational Risk Management", "children": []}, {"id": "45", "name": "Compliance Risk Monitoring", "children": []}, {"id": "46", "name": "Risk Reporting and Communication", "children": []}, {"id": "47", "name": "Insurance and Risk Transfer", "children": []}, {"id": "48", "name": "Risk Assessment and Framework Development", "children": []}, {"id": "49", "name": "Scenario Analysis and Stress Testing", "children": []}, {"id": "50", "name": "Risk Culture and Awareness Training", "children": []}, {"id": "51", "name": "Risk Mitigation Strategy Development", "children": []}]}, {"id": "5", "name": "IT Infrastructure Management", "children": [{"id": "52", "name": "Cloud Infrastructure Management", "children": []}, {"id": "53", "name": "Cybersecurity Management", "children": []}, {"id": "54", "name": "Application Lifecycle Management", "children": []}, {"id": "55", "name": "Network Operations Management", "children": []}, {"id": "56", "name": "Data Center Operations Management", "children": []}, {"id": "57", "name": "Disaster Recovery and Business Continuity Planning", "children": []}, {"id": "58", "name": "IT Asset Management", "children": []}, {"id": "59", "name": "IT Service Management", "children": []}, {"id": "60", "name": "Performance Monitoring and Analytics", "children": []}, {"id": "61", "name": "Vendor and Contract Management", "children": []}]}, {"id": "6", "name": "Financial Services Delivery", "children": [{"id": "62", "name": "Personal Banking Services", "children": []}, {"id": "63", "name": "Mortgage Services", "children": []}, {"id": "64", "name": "Investment Products Management", "children": []}, {"id": "65", "name": "Business Banking Solutions", "children": []}, {"id": "66", "name": "Wealth Management Services", "children": []}, {"id": "67", "name": "Financial Planning Services", "children": []}, {"id": "68", "name": "Customer Support and Advisory", "children": []}, {"id": "69", "name": "Digital Banking Solutions", "children": []}, {"id": "70", "name": "Payment Solutions", "children": []}, {"id": "71", "name": "Card Services Management", "children": []}]}, {"id": "7", "name": "Strategic Financial Planning", "children": [{"id": "72", "name": "Financial Budgeting", "children": []}, {"id": "73", "name": "Financial Forecasting", "children": []}, {"id": "74", "name": "Performance Analysis", "children": []}, {"id": "75", "name": "Financial Risk Assessment", "children": []}, {"id": "76", "name": "Capital Structure Management", "children": []}, {"id": "77", "name": "Cost Management Strategies", "children": []}, {"id": "78", "name": "Investment Strategy Development", "children": []}, {"id": "79", "name": "Financial Reporting and Compliance", "children": []}, {"id": "80", "name": "Strategic Scenario Planning", "children": []}, {"id": "81", "name": "Stakeholder Engagement in Financial Strategy", "children": []}]}, {"id": "8", "name": "Digital Transformation", "children": []}, {"id": "9", "name": "Compliance and Regulatory Management", "children": []}, {"id": "10", "name": "Sustainability Initiatives", "children": []}, {"id": "11", "name": "Investor Relations Management", "children": []}, {"id": "12", "name": "Talent Management and Development", "children": []}, {"id": "13", "name": "Sales and Distribution Strategy", "children": []}, {"id": "14", "name": "Marketing and Brand Management", "children": []}, {"id": "15", "name": "Customer Onboarding", "children": []}, {"id": "16", "name": "Innovation Management", "children": []}, {"id": "17", "name": "Data Analytics and Insights", "children": []}, {"id": "18", "name": "Service Operations Management", "children": []}, {"id": "19", "name": "Partnership and Alliance Management", "children": []}, {"id": "20", "name": "Core Banking Operations", "children": []}, {"id": "21", "name": "Corporate Social Responsibility", "children": []}]}]};

        function calculateNodeSize(node) {
            if (!node.children || node.children.length === 0) {
                return {
                    width: BOX_MIN_WIDTH,
                    height: BOX_MIN_HEIGHT
                };
            }

            const childSizes = node.children.map(calculateNodeSize);

            let bestLayout = {
                rows: 1,
                cols: node.children.length,
                width: 0,
                height: 0,
                deviation: Infinity,
                positions: []
            };

            for (let rows = 1; rows <= node.children.length; rows++) {
                const cols = Math.ceil(node.children.length / rows);
                
                let rowHeights = new Array(rows).fill(0);
                let colWidths = new Array(cols).fill(0);
                
                for (let i = 0; i < node.children.length; i++) {
                    const row = Math.floor(i / cols);
                    const col = i % cols;
                    const size = childSizes[i];
                    
                    rowHeights[row] = Math.max(rowHeights[row], size.height);
                    colWidths[col] = Math.max(colWidths[col], size.width);
                }
                
                const gridWidth = colWidths.reduce((a, b) => a + b, 0) + (cols - 1) * HORIZONTAL_GAP;
                const gridHeight = rowHeights.reduce((a, b) => a + b, 0) + (rows - 1) * VERTICAL_GAP;
                
                const totalWidth = gridWidth + 2 * PADDING;
                const totalHeight = gridHeight + 2 * PADDING;
                const aspectRatio = totalWidth / totalHeight;
                const deviation = Math.abs(aspectRatio - DEFAULT_TARGET_ASPECT_RATIO);

                const positions = [];
                let yOffset = PADDING;
                
                for (let row = 0; row < rows; row++) {
                    let xOffset = PADDING;
                    for (let col = 0; col < cols; col++) {
                        const index = row * cols + col;
                        if (index < node.children.length) {
                            positions[index] = {
                                x: xOffset,
                                y: yOffset,
                                width: colWidths[col],
                                height: rowHeights[row]
                            };
                        }
                        xOffset += colWidths[col] + HORIZONTAL_GAP;
                    }
                    yOffset += rowHeights[row] + VERTICAL_GAP;
                }

                if (deviation < bestLayout.deviation) {
                    bestLayout = {
                        rows,
                        cols,
                        width: totalWidth,
                        height: totalHeight,
                        deviation,
                        positions
                    };
                }
            }

            return bestLayout;
        }

        function layoutTree(node, x = 0, y = 0) {
            const layout = calculateNodeSize(node);
            node.x = x;
            node.y = y;
            node.width = layout.width;
            node.height = layout.height;

            if (node.children && node.children.length > 0) {
                node.children.forEach((child, i) => {
                    const pos = layout.positions[i];
                    layoutTree(
                        child,
                        x + pos.x,
                        y + pos.y
                    );
                    child.width = pos.width;
                    child.height = pos.height;
                });
            }

            return node;
        }

        function createSVGElement(tagName, attributes = {}) {
            const element = document.createElementNS("http://www.w3.org/2000/svg", tagName);
            Object.entries(attributes).forEach(([key, value]) => {
                element.setAttribute(key, value);
            });
            return element;
        }

        function wrapText(text, width) {
            const words = text.split(' ');
            const lines = [];
            let currentLine = words[0];

            // Create temporary SVG to measure text
            const svg = createSVGElement('svg');
            const tempText = createSVGElement('text', {
                'font-size': '0.875rem',
                'font-family': 'system-ui, -apple-system, sans-serif'
            });
            svg.appendChild(tempText);
            document.body.appendChild(svg);

            for (let i = 1; i < words.length; i++) {
                tempText.textContent = currentLine + ' ' + words[i];
                const textWidth = tempText.getComputedTextLength();

                if (textWidth < width - 20) {  // 20px padding
                    currentLine += ' ' + words[i];
                } else {
                    lines.push(currentLine);
                    currentLine = words[i];
                }
            }
            lines.push(currentLine);

            document.body.removeChild(svg);
            return lines;
        }

        function renderNode(node) {
            const group = createSVGElement("g");

            const rect = createSVGElement("rect", {
                x: node.x,
                y: node.y,
                width: node.width,
                height: node.height,
                fill: node.children?.length ? "#f8fafc" : "#fff",
                stroke: "#475569",
                "stroke-width": "1",
                rx: "4"
            });
            group.appendChild(rect);

            // Wrap text and create multiple text lines
            const lines = wrapText(node.name, node.width);
            const totalTextHeight = lines.length * LINE_HEIGHT;
            const startY = node.children?.length ? 
                node.y + PADDING_TOP : 
                node.y + (node.height - totalTextHeight) / 2;

            lines.forEach((line, index) => {
                const text = createSVGElement("text", {
                    x: node.x + node.width / 2,
                    y: startY + (index * LINE_HEIGHT),
                    "text-anchor": "middle",
                    "dominant-baseline": "hanging"
                });
                text.textContent = line;
                group.appendChild(text);
            });

            if (node.children) {
                node.children.forEach(child => {
                    group.appendChild(renderNode(child));
                });
            }

            return group;
        }

        function init() {
            const layoutedTree = layoutTree(JSON.parse(JSON.stringify(capabilityModel)));
            
            const svg = createSVGElement("svg", {
                width: layoutedTree.width + 40,
                height: layoutedTree.height + 40,
                viewBox: `0 0 ${layoutedTree.width + 40} ${layoutedTree.height + 40}`,
                class: "bg-white"
            });

            svg.appendChild(renderNode(layoutedTree));
            document.getElementById("svg-container").appendChild(svg);
        }

        // Initialize when the page loads
        document.addEventListener("DOMContentLoaded", init);
    </script>
</body>
</html>